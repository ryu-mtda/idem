type nat = Z | S of nat

(* add (x, y) = (x + y, y) *)
iso rec add = case
| (m, Z) <-> (m, Z)
| (m, S n) <-> let (m, n) = add (S m, n) in (m, S n)
in

let g = fun x -> let (y, z) = add (x, x) in y
in

idem f =
  add
with
  (x, y) -> (
    let t = g y in
    let (u, v) = add (t, t) in
    (u, y)
  )
in

idem h = (x, y) -> (
  let t = g y in
  let (u, v) = add (t, t) in
  (u, y)
)
in

let (x, y) = f (3, 5) in
f (x, y)

type bool    = False | True
type 'a list = Nil (* [] *) | Cons (* :: *) of 'a * 'a list
type nat     = Z (* 0 *) | S (* n *) of nat

iso recover f = case i <->
  let (o, g) = f i in
  let (o, o') = (o, o) in
  (o, inv f (o', g))
in

iso rec merge leq = case
| ([], [])           <-> ([], [])
| (x :: xs, [])      <-> (x :: xs, [False])
| ([], y :: ys)      <-> (y :: ys, [True])
| (x :: xs, y :: ys) <->
  let (xs, g :: g' :: gs) =
    match (leq (x, y), xs, ys) with
    | ((True, (x, y)), xs, ys)  <->
      let (merged, g) = merge leq (xs, y :: ys) in
      (x :: merged, False :: g)
    | ((False, (x, y)), xs, ys) <->
      let (merged, g) = merge leq (x :: xs, ys) in
      (y :: merged, True :: g)
  in (xs, g :: g' :: gs)
in

iso rec len = case
| []      <-> (0, [])
| x :: xs <-> let (n, xs) = len xs in (S n, x :: xs)
in

iso rec rev' = case
| (xs, (0, []))        <-> (xs, (0, []))
| (xs, (S n, y :: ys)) <->
  let (xs, (n, ys)) = rev' (y :: xs, (n, ys)) in
  (xs, (S n, ys))
in

iso rev = case xs <->
  let (xs, (n, [])) = rev' ([], len xs) in
  inv len (n, xs)
in

iso rec partition' = case
| (xs, ys, 0)        <-> (xs, ys, 0)
| (xs, y :: ys, S n) <->
  let (xs, ys, n) = partition' (y :: xs, ys, n) in
  (xs, ys, S n)
in

iso partition = case (xs, n) <->
  let (xs, ys, n) = partition' ([], xs, n) in
  (rev (inv len (n, xs)), ys)
in

iso rec halve = case
| 0       <-> (0, 0)
| 1       <-> (1, 0)
| S (S n) <-> let (m, n) = halve n in (S m, S n)
in

iso split = case xs <->
  let (n, xs) = len xs in
  let (m, n) = halve n in
  let (xs, ys) = partition (xs, m) in
  (xs, inv len (n, ys))
in

iso rec msort' leq = case xs <->
  match split xs with
  | ([], [])           <-> ([], [])
  | ([x], [])          <-> ([x], [])
  | (x :: xs, y :: ys) <->
    let (xs, gx) = msort' leq (x :: xs) in
    let (ys, gy) = msort' leq (y :: ys) in
    let (xs, g) = merge leq (xs, ys) in
    (xs, g :: inv split (gx, gy))
in

iso msort leq = recover {msort' leq} in

iso rec nat_leq = case
| (0, S n)   <-> (True, (0, S n))
| (S m, 0)   <-> (False, (S m, 0))
| (0, 0)     <-> (True, (0, 0))
| (S m, S n) <-> let (b, (m, n)) = nat_leq (m, n) in (b, (S m, S n))
in

msort nat_leq [10; 5; 5; 1; 2; 9; 7; 8; 0; 4; 6; 5; 6]


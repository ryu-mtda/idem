type bool            = False | True
type 'a option       = None | Some of 'a
type ('l, 'r) either = Left of 'l | Right of 'r
type 'a list         = Nil (* [] *) | Cons (* :: *) of 'a * 'a list
type nat             = Z (* 0 *) | S (* n *) of nat

iso rec len = case
| []      <-> (0, [])
| x :: xs <-> let (n, xs) = len xs in (S n, x :: xs)
in

iso rec map f = case
| []     <-> []
| h :: t <-> f h :: map f t
in

iso rec double = case
| []      <-> []
| x :: xs <-> x :: x :: double xs
in

iso rec rev' = case
| (l, (0, []))        <-> (l, (0, []))
| (l, (S n, x :: xs)) <->
  let (l, (n, xs)) = rev' (x :: l, (n, xs)) in
  (l, (S n, xs))
in

iso rev = case l <->
  let (l, (n, [])) = rev' ([], len l) in
  inv len (n, l)
in

iso rec foldl_map f = case
| (acc, [])      <-> (acc, [])
| (acc, x :: xs) <->
  let (acc, x) = f (acc, x) in
  let (acc, xs) = foldl_map f (acc, xs) in
  (acc, x :: xs)
in

iso rec repeat = case
| (0, x)   <-> ([], x)
| (S n, x) <->
  let (xs, x) = repeat (n, x) in
  (x :: xs, x)
in

iso rec split = case
| []           <-> ([], [])
| (x, y) :: tl <->
  let (xs, ys) = split tl in
  (x :: xs, y :: ys)
in

iso merge = inv split in

iso rec partition' = case
| (l, r, 0)         <-> (l, r, 0)
| (l, x :: xs, S n) <->
  let (l, xs, n) = partition' (x :: l, xs, n) in
  (l, xs, S n)
in

iso partition = case (r, n) <->
  let (l, r, n) = partition' ([], r, n) in
  (rev (inv len (n, l)), r)
in

iso concat = inv partition in

(* add (m, n) = (m + n, n) *)
iso rec add = case
| (m, S n) <-> let (m, n) = add (S m, n) in (m, S n)
| (m, 0)   <-> (m, 0)
in

iso rec sum = case l <-> foldl_map add (0, l) in

iso rec iota' = case
| 0   <-> []
| S n <-> let (n, n') = (n, n) in n :: iota' n'
in

iso iota = case n <-> rev (iota' n) in

iso rec push_back = case
| ([], y)      <-> [y]
| (x :: xs, y) <->
  let y :: xs = push_back (xs, y) in
  x :: y :: xs
in

double (iota 5)

